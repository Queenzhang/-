### 《大话数据结构》读书笔记

#### 一.数据结构绪论

+ 数据结构：相互之间存在一种或多种特定关系的数据元素的集合
+ 数据结构是一门研究非数值计算的程序设计问题中的操作对象，以及它们之间的关系和操作等相关问题的学科。
+ 程序设计 = 数据结构 + 算法
+ 数据：描述客观事物的符号，是计算机中可操作的对象，是能被计算机识别，并输入给计算机处理的符号集合
  + 数值类型：整型、实型等
  + 非数值型：字符、声音、图像、视频等
+ 数据元素：组成数据的、有一定意义的基本单位，在计算机中通常作为整体处理，也被称为记录
+ 数据项：一个数据元素可以由若干个数据项组成，是数据不可分割的最小单位
+ 数据对象：性质相同的数据元素的集合，是数据的子集
+ 逻辑结构：数据对象中数据元素之间的相互关系
  + 集合结构：集合结构中的数据元素除了同属于一个集合外，它们之间没有其他关系
  + 线性结构：线性结构中的数据元素之间是一对一的关系
  + 树形结构：树形结构中的数据元素之间存在一种一对多的层次关系
  + 图形结构：图形结构的数据元素是多对多的关系
+ 物理结构：是指数据的逻辑结构在计算机中的存储形式
  + 顺序存储结构：把数据元素存放在地址连续的存储单元里，其数据间的逻辑关系和物理关系是一致的
  + 链式存储结构：把数据元素存放在任意的存储单元里，这组存储单元可以是连续的，也可以是不连续的
+ 数据类型：一组性质相同的值的集合及定义在此集合上的一些操作的总称
+ 抽象：抽取出事物具有的普遍性的本质
+ 抽象数据类型：一个数学模型及定义在该模型上的一组操作
+ 抽象的意义在于数据类型的数学抽象特性
+ 抽象数据类型体现了程序设计中问题分解、抽象和信息隐藏的特性

#### 二.算法

+ 算法：解决特定问题求解步骤的描述，在计算机中表现为指令的有限序列，并且每条指令表示一个或多个操作

+ 算法的基本特性：
  + 输入：算法具有零个或多个输入
  + 输出：算法至少有一个或多个输出
  + 有穷性：算法在执行有限的步骤之后，自动结束而不会出现无限循环，并且每一个步骤在可接受的时间内完成
  + 确定性：算法的每一步骤都具有确定的含义，不会出现二义性
  + 可行性：算法的每一步必须是可行的，即每一步都能够通过执行有限次数完成
  
+ 算法设计的要求：
  + 正确性：算法至少应该具有输入、输出和加工处理无歧义性、能正确反映问题的需求、能够得到问题的正确答案
    + 算法正确性的四个层次
      1. 算法程序没有错误
      2. 算法程序对于合法的输入数据能够产生满足要求的输出结果
      3. 算法程序对于非法的输入数据能够得到满足规格说明的结果
      4. 算法程序对于精心选择的，甚至刁难的测试数据都有满足要求的输出结果
  + 可读性：便于阅读、理解和交流
  + 健壮性：当输入数据不合法时，算法也能够做出相关处理，而不是产生异常或莫名其妙的结果
  + 时间效率高和存储量低
  
+ 算法效率的度量方法
  + 事后统计法：主要是通过设计好的测试程序和数据，利用计算机计时器对不同算法编制的程序的运行时间进行比较，从而确定算法效率的高低（此方法缺陷较大）
  + 事前分析估算法：在计算机程序编制前，依据统计方法对算法进行估算
  
+ 函数的渐近增长：给定两个函数f(n)和g(n)，如果存在一个整数N，使得对于所有的n>N，f(n)总是比g(n)大，那么，我们说f(n)的增长渐近快于g(n)。
  + 可以忽略加法常数
  + 最高次项相乘的常数并不重要
  + 最高次项的指数大的，函数随着n的增长，结果也会变得增长特别快
  + 判断一个算法的效率时，函数中的常数和其他次要项常常可以忽略，而更应该关注主项（最高阶项）的阶数
  
+ 算法时间复杂度：在进行算法分析时，语句总的执行次数T(n)是关于问题规模n的函数，进而分析T(n)随n的变化情况并确定T(n)的数量级。记作：T(n) = O(f(n))。表示随问题规模n的增大，算法执行时间增长率和f(n)的增长率相同，称作算法的渐近时间复杂度，其中f(n)是问题规模n的某个函数

+ 推导大O阶方法：

  1. 用常数1取代运行时间中的多有加法常数
  2. 在修改后的运行次数函数中，只保留最高阶项
  3. 如果最高阶项存在且不是1，则去除与这个项相乘的常数。

+ 常见的时间复杂度：

  ![截屏2021-10-07 下午3.48.18](/Users/queen/Library/Application Support/typora-user-images/截屏2021-10-07 下午3.48.18.png)

  + O(1)<O(logn)<O(n)<O(nlogn)<O(n^2)<O(n^3)<O(2^n)<O(n!)<O(n^n)

+ 最坏情况：最坏情况运行时间是一种保证。通常，除非特别指定，我们提到的运行时间都是最坏情况的运行时间

+ 平均情况：平均运行时间是期望的运行时间

+ 算法空间复杂度：通过计算算法所需的存储空间实现，算法空间复杂度的计算公式记作：S(n) = O(f(n))，其中，n为问题的规模，f(n)为语句关于n所占存储空间的函数

+ 若算法执行时所需的辅助空间相对于输入数据量而言是个常数，则称此算法为原地工作，空间复杂度为O(1)

#### 三.线性表

+ 线性表(List)：零个或多个数据元素的有限序列

+ 数学语言定义：若将线性表记为（a<sub>1</sub>，……，a<sub>i-1</sub>，a<sub>i</sub>，a<sub>i+1</sub>,……，a<sub>n</sub>），则表中a<sub>i-1</sub>领先于a<sub>i</sub>，a<sub>i</sub>领先于a<sub>i+1</sub>,称a<sub>i-1</sub>是a<sub>i</sub>的直接先驱元素，a<sub>i+1</sub>是a<sub>i</sub>的直接后继元素。当i=1，2，……，n-1时，a<sub>i</sub>有且仅有一个直接后继，当当i=2，3，……，n时，a<sub>i</sub>有且仅有一个直接前驱。

+ 线性表元素的个数n（n≥0）定义为线性表的长度，当n=0，成为空表

+ 在复杂线性表中，一个数据元素可以由若干个数据项组成

+ 线性表的顺序存储结构：用一段地址连续的存储单元依次存储线性表的数据元素
  + 一维数组来实现顺序存储结构
  + 描述顺序存储结构的三个属性：
    1. 存储空间的其实位置：数值data，它的存储位置就是存储空间的存储位置
    2. 线性表的最大存储容量：数组长度MaxSize
    3. 线性表的当前长度：length
  
+ 在任意时刻，线性表的长度应该小于等于数组的长度

+ 地址：存储器中的每个存储单元都有自己的编号，这个编号称为地址
  + LOC(a<sub>i</sub>)=LOC(a<sub>1</sub>)+(i-1)*c
  
+ 顺序存储结构的插入与删除
  + 插入算法：
    + 如果插入位置不合理，抛出异常
    + 如果线性表长度大于等于数组长度，则抛出异常或动态增加容量
    + 从最后一个元素开始向前遍历到第i个位置，分别将它们都向后移动一个位置
    + 将要插入元素填入位置i处
    + 表长加1
  + 删除算法：
    + 如果删除位置不合理，抛出异常
    + 取出删除元素
    + 从删除元素位置开始遍历到最后一个元素位置，分别将它们都向前移动一个位置
    + 表长减1
  
+ 线性表顺序存储结构的优缺点
  + 优点：
    + 无须为表示表中元素之间的逻辑关系而增加额外的存储空间
    + 可以快速地存取表中任一位置的元素
  + 缺点：
    + 插入和删除操作需要移动大量元素
    + 当线性表长度变化较大时，难以确定存储空间的容量
    + 造成存储空间的“碎片”
  
+ 线性表链式存储结构定义：为了表示每个数据元素a<sub>i</sub>与其直接后继数据元素a<sub>i+1</sub>之间的逻辑关系，对数据元素a<sub>i</sub>来说，除了存储其本身的信息之外，还需要存储一个指示其直接后继的信息。我们把存储数据元素信息的域称为数据域，把存储直接后继位置的域称为指针域。指针域中存储的信息称做指针或链。这两部分信息组成数据元素a<sub>i</sub>的存储映像，称为结点Node。n个结点链结成一个链表，即为线性表的链式存储结构，因为此链表的每个结点中只包含一个指针域，所以叫做单链表

  + 头指针：链表中第一个节点的存储位置。线性链表的最后一个结点指针为“空”（NULL）

  + 头结点：单链表的第一个结点前附设的一个结点。头结点的数据域可以不存储任何信息

    ![截屏2021-10-11 下午9.03.17](/Users/queen/Library/Application Support/typora-user-images/截屏2021-10-11 下午9.03.17.png)

  + 如果p->data = a<sub>i</sub>,那么p->next->data = a<sub>i+1</sub>

+ 单链表的读取

  + 获得链表第i个数据的算法思路：
    1. 声明一个结点p指向链表第一个结点，初始化j从1开始	
    2. 当j<i时，就遍历链表，让p的指针向后移动，不断指向下一结点，j累加1
    3. 若到链表末尾p为空，则说明第i个元素不存在
    4. 否则查找成功，返回结点p的数据

+ 单链表的插入与删除：

  + 单链表第i个数据插入结点的算法：
    1. 声明一结点p指向链表第一个结点，初始化j从1开始
    2. 当j<i时，就遍历链表，让p的指针向后移动，不断指向下一结点，j累加1
    3. 若到链表末尾p为空，则说明第i个元素不存在
    4. 否则查找成功，在系统中生成一个空结点s
    5. 将数据元素e赋值给s->data
    6. 单链表的插入标准语句：s->next = p->next; p->next=s
    7. 返回成功

  + 单链表第i个数据删除结点的算法：
    1. 声明一结点p指向链表第一个结点，初始化j从1开始
    2. 当j<i时，就遍历链表，让p的指针向后移动，不断指向下一结点，j累加1
    3. 若到链表末尾p为空，则说明第i个元素不存在
    4. 否则查找成功，将欲删除的结点p->next赋值给q
    5. 单链表的删除标准语句p->next=q->next
    6. 将q结点中的数据赋值给e，作为返回
    7. 释放q结点
    8. 返回成功
  + 对于插入或删除数据越频繁的操作，单链表的效率优势就越明显

+ 单链表的整表创建：

  1. 声明一结点p和计数器表量i
  2. 初始化一空链表L
  3. 让L的头结点的指针指向NULL，即建立一个带头结点的单链表
  4. 循环
     + 生成一新结点赋值给p
     + 随机生成一数字赋值给p的数据域p->data
     + 将p插入到头结点与前一新结点之间

+ 单链表的整表删除：

  1. 声明一结点p和q
  2. 将第一个结点赋值给p
  3. 循环
     + 将下一结点赋值给q
     + 释放p
     + 将q赋值给p

+ 单链表结构与顺序存储结构优缺点

  ![截屏2021-10-11 下午9.54.02](/Users/queen/Library/Application Support/typora-user-images/截屏2021-10-11 下午9.54.02.png)

+ 静态链表：用数组描述的链表

+ 循环链表：将单链表中终端结点的指针端由空指针改为指向头结点，就使整个单链表形成一个环，这种头尾相接的单链表称为单循环链表

+ 双向链表：在单链表的每个结点中，再设置一个指向其前驱结点的指针域

#### 四.栈与队列

+ 栈：限定仅在表尾进行插入和删除操作的线性表，后进先出（LIFO）
  + 栈顶：允许插入和删除的一端
  + 栈底
  + 空栈：不含任何数据元素的栈
+ 进栈（push）出栈（pop）变化形式
  + 最先进栈的元素，不一定只能最后出栈
  + 312的出栈次序不会出现（只有三个元素的情况下）
+ 栈的顺序存储结构
  + 数组下标为0的一端作为栈底
  + 进栈和出栈的时间复杂度均为O（1）
  + 缺点：事先必须确定数组空间的大小，万一不够用了，就需要用编程手段扩展数组的容量
+ 两栈共享空间
  + 数组有两个端点，两个栈有两个栈底，让一个栈的栈底为数组的始端，即下标为0处，另一个栈为栈的末端，即下标为数组长度n-1处。如果两个栈增加元素，就是两端点栈向中间延伸（只针对两个具有相同数据类型的栈的技巧）
+ 栈的链式存储结构
  + 把栈顶放在单链表的头部
  + 进栈和出栈的时间复杂度都为O（1）
+ 如果栈的使用过程中元素变化不可预料，有时很小，有时非常大，那么最好是用连战，反之，如果它的变化在可控范围内，建议使用顺序栈
+ 栈的作用
  + 简化了程序设计的问题，划分了不同关注层次，使得思考范围缩小，更加聚焦于要解决的核心问题
+ 栈的应用
  + 递归：把一个直接调用自己或通过一系列的调用语句间接地调用自己的函数，称作递归函数。每一个递归定义必须至少满足一个条件，满足时递归不再进行，即不再引用自身而是返回值退出
    + 斐波那契数列：前面相邻两项之和，构成了后一项
    + 递归和迭代
      + 迭代：使用的是循环结构，不需要反复调用函数和占用额外的内存
      + 递归：使用的是选择结构，能使程序的结构更清晰、更简洁、更容易让人理解，从而减少读懂代码的时间，但大量的递归会建立函数的副本，耗费大量的时间和内存
  + 四则运算表达式求值
    + 后缀表示法：从左到右遍历表达式的每个数字和符号，遇到数字就进栈，遇到符号就将处于栈顶两个数字出栈，进行运算，运算结果进栈，一直到最终获得结果
    + 中缀表达式（标准四则运算表达式）转后缀表达式：从左到右遍历中缀表达式的每个数字和符号，若是数字就输出，即称为后缀表达式的一部分；若是符号，则判断其与栈顶符号优先级，是右括号或优先级低于栈顶符号则栈顶元素依次出栈并输出，并将当前符号进栈，一直到最终输出后缀表达式为止
+ 队列：只允许在一端进行插入操作、而在另一端进行删除操作的线性表，先进先出（FIFO）
+ 循环队列
  + 队列顺序存储不足：出队列的时间复杂度为O（n）
  + 定义：头尾相接的顺序存储结构
  + 队列计算长度公式：(rear-front+QueueSize)%QueueSize
  + 不足：面临数组可能会溢出的问题
+ 队列的链式存储结构
  + 线性表的单链表，只不过只能尾进头出
+ 循环队列和链队列的比较：
  + 时间上，它们的基本操作都是O（1），如果入队出队频繁，则还是有差异
  + 空间上，链队列更加灵活
  + 在可以确定队列长队最大值的情况下，建议用循环队列，如果无法预估队列长度，则用链队列

#### 五.串

+ 串是由零个或多个字符组成的有序序列，又名字符串

  + 记为：s=a<sub>1</sub>a<sub>2</sub>……a<sub>n</sub>(n大于等于0)
  + 串中的字符数目n称为串的长度
  + 零个字符的串称为空串

+ 串的比较

  + 通过组成串的字符之间的编码来进行比较
    + n<m,且a<sub>i</sub>=b<sub>i</sub>(i=1,2,……，n)
    + 存在某个k≤min（m,n）,使得a<sub>i</sub>=b<sub>i</sub>(i=1,2,……，k-1)，a<sub>k</sub>=b<sub>k</sub>

+ 串的抽象数据类型

  + 串的逻辑结构和线性表相似，不同之处在于串针对的是字符集
  + 串的基本操作与线性表有很大差别，线性表更关注单个元素，串中更多的是查找子串位置、替换子串、得到指定位置子串等

+ 串的存储结构

  + 串的顺序存储结构是用一组地址连续的存储单元来存储串中的字符序列的。一般用定长数组定义
  + 串的链式存储结构与线性表相似，一个结点可以存放一个或多个字符，最后一个结点未被占满时，可以用？“#”或其他非串值字符补全
  + 串的链式存储结构除了在连接串与串操作时有一定方便之外，总的来说不如顺序存储灵活，性能也不如顺序存储结构好

+ 朴素的模式匹配算法：对主串的每一个字符作为子串开头，与要匹配的字符串进行匹配。对主串做大循环，每个字符开头做要匹配的字符串的长度的小循环，直到匹配成功或全部遍历完成为止

+ KMP模式匹配算法

  + 

  /璇玑图/

#### 六.树

+ 树是n（n≥0）个结点的有限集。n=0时称为空树。在任意一颗非空树中：（1）有且仅有一个特定的称为根（root）的结点；（2）当n>1时，其余结点可分为m（m>0）个互不相交的有限集T<sub>1</sub>、T<sub>2</sub>、……、T<sub>m</sub>，其中每一个集合本身又是一棵树，并且称为根的子树（SubTree）

  + n>0时根结点是唯一的，不可能存在多个根结点
  + m>0时，子树的个数没有限制，但它们一定是互不相交的

+ 结点的度：结点拥有的子树数

  + 叶结点（终端结点）：度为0的结点
  + 分支结点（非终端结点）：度不为0的结点

+ 树的度（degree）：树内各结点的度的最大值

+ 结点的子树的根称为该结点的孩子（child），相应的，该结点称为孩子的双亲（parent）。同一个双亲的孩子之间互称兄弟。

  + 结点的祖先是从根到该结点所经分支上的所有结点
  + 以某结点为根的子树中的任一结点都称为该结点的子孙

+ 结点的层次（level）：根为第一层，根的孩子为第二层。若结点在第l层，则其子树的根就在第l+1层。其双亲在同一层的结点互为堂兄弟。

+ 树的深度（depth）/高度：树中结点的最大层次

+ 如果将树中结点的各子树看成从左至右是有次序的，不能互换的，则称该树为有序树，否则称为无须树

+ 森林是m（m≥0）课互不相交的树的集合

  ![截屏2021-10-24 下午11.11.21](/Users/queen/Library/Application Support/typora-user-images/截屏2021-10-24 下午11.11.21.png)

+ ​	树的存储结构

  + 双亲表示法：以一组连续空间存储树的结点，同时在每个结点中，附设一个指示器指示双亲结点到链表中的位置
  + 孩子表示法：把每个结点的孩子结点排列起来，以单链表作存储结构，则n个结点有n个孩子链表，如果是叶子结点则此单链表为空。然后呢n个头指针又组成一个线性表，采用顺序存储结构，存放进一个一维数组中。
  + 孩子兄弟表示法:设置两个指针，分别指向该结点的第一个孩子和此结点的右兄弟
  + 存储结构的设计是一个非常灵活的过程。一个存储结构设计得是否合理，取决于基于该存储结构的运算是否适合、是否方便、时间复杂度好不好等
  
+ 二叉树：n（n≥0）个结点的有限集合，该集合或者为空集（称为空二叉树），或者由一个根结点和两颗互不相交的、分别称为根结点的左子树和右子树的二叉树组成

+ 二叉树特点

  + 每个结点最多有两颗子树，所以二叉树中不存在度大于2的结点
  + 左子树和右子树是有顺序的，次序不能任意颠倒
  + 即使树中某结点只有一颗子树，也要区分它是左子树还是右子树

+ 二叉树的5种形态

  + 空二叉树
  + 只有一个根结点
  + 根结点只有左子树
  + 根结点只有右子树
  + 根结点既有左子树又有右子树

+ 特殊二叉树

  + 斜树：所有结点都只有左子树的二叉树叫左斜树，所有结点都是只有右子树的二叉树叫右斜树。两者的统称为斜树
  + 满二叉树：所有分支结点都存在左子树和右子树，并且所有叶子都在同一层上的二叉树
  + 完全二叉树：一颗具有n个结点的二叉树按层序编号，如果编号为i（1≤i≤n）的结点与同样深度的满二叉树中编号为i的结点在二叉树中位置完全相同，则称为完全二叉树

+ 二叉树的性质

  + 在二叉树的第i层上至多有2<sup>i-1</sup>个结点（i≥1）
  + 深度为k的二叉树至多有2<sup>k</sup>-1个结点（k≥1）
  + 对任何一颗二叉树T，如果其终端结点数为n<sub>0</sub>,度为2的结点树为n<sub>2</sub>,则n<sub>0</sub>=n<sub>2</sub>+1
  + 具有n个结点的完全二叉树的深度为⌊log2n⌋+1,⌊x⌋表示不大于x的最大整数
  + 如果对一颗有n个结点的完全二叉树（其深度为⌊log2n⌋+1）的结点按层序编号，对任一结点i（1≤i≤n）有
    1. 如果i=1，则结点i是二叉树的根，无双亲；如果i>1,则其双亲是结点⌊i/2⌋
    2. 如果2i>n,则结点i无左孩子；否则其左孩子是结点2i
    3. 如果2i+1>n,则结点i无右孩子，否则其右孩子是结点2i+1

+ 二叉树的存储结构

  + 二叉树顺序存储结构
  + 二叉链表

+ 二叉树遍历：从根结点出发，按照某种次序依次访问二叉树中所有结点，使得每个结点被访问一次且仅被访问一次

  + 前序遍历：先访问根结点，然后前序遍历左子树，再前序遍历右子树

    ![截屏2021-10-26 下午11.10.06](/Users/queen/Library/Application Support/typora-user-images/截屏2021-10-26 下午11.10.06.png)

  + 中序遍历：从根结点开始，中序遍历根结点的左子树，然后访问根结点，最后中序遍历右子树

    ![截屏2021-10-26 下午11.13.52](/Users/queen/Library/Application Support/typora-user-images/截屏2021-10-26 下午11.13.52.png)

  + 后序遍历：从左到右先叶子后结点的方式遍历访问左右子树，最后访问根结点

    ![截屏2021-10-26 下午11.15.53](/Users/queen/Library/Application Support/typora-user-images/截屏2021-10-26 下午11.15.53.png)

  + 层序遍历：从树的第一层，也就是根结点开始访问，从上而下逐层遍历，在同一层中，按从左到右的顺序对结点逐个访问

    ![截屏2021-10-26 下午11.19.19](/Users/queen/Library/Application Support/typora-user-images/截屏2021-10-26 下午11.19.19.png)
    
    + 已知前序遍历序列和中序遍历序列，可以为宜确定一颗二叉树
    + 已知后序遍历序列和中序遍历序列，可以唯一确定一颗二叉树
    + 已知前序和后序遍历，不能确定一颗二叉树

+ 二叉树的建立

  + 将二叉树中每个结点的空指针引出一个虚结点，其值为一特定值，如“#”。称这种处理后的二叉树为原二叉树的扩展二叉树
  + 利用递归的原理

+ 线索二叉树

  + 指向前驱和后继的指针称为线索，加上线索的二叉树表称为线索链表，相应的二叉树称为线索二叉树
  + 对二叉树以某种次序遍历使其变为线索二叉树的过程称作线索化
  + lchild  ltag  data  rtag  rchild

+ 树、森林、二叉树的转换

  + 树转换为二叉树
    1. 加线。在所有兄弟结点之间加一条连线
    2. 去线。对树中每个结点，只保留它与第一个孩子结点的连线，删除它与其他孩子结点之间的连线
    3. 层次调整。以树的根结点为轴心，将整颗树顺时针旋转为一定角度，使之结构层次分明。注意第一个孩子是二叉树结点的左孩子，兄弟转换过来的孩子是结点的右孩子
  + 森林转换为二叉树
    1. 把每个树转换为二叉树
    2. 把第一棵二叉树不动，从第二颗二叉树开始，依次把后一颗二叉树的根结点作为前一颗二叉树的根结点的右孩子，用线连接起来。当所有的二叉树连接起来以后就得到了由森林转换来的二叉树
  + 二叉树转换为树
    1. 加线。若某结点的左孩子结点存在，则将这个左孩子的n个右孩子结点都作为此结点的孩子。将该结点与这些右孩子结点用线连接起来
    2. 去线。删除原二叉树所有结点与其右孩子结点的连线
    3. 层次调整。使之结构层次分明
  + 二叉树转换为森林
    1. 从根结点开始，若右孩子存在，则把与右孩子结点的连线删除，再查看分离后的二叉树，若右孩子存在，则连线删除……，直到所有右孩子连线都删除为止，得到分离的二叉树
    2. 再将每棵分离后的二叉树转换为树即可
  + 树的遍历
    + 先根遍历，即先访问树的根结点，然后依次先遍历根的每棵子树。
    + 后根遍历，即先依次后根遍历每棵子树，然后再访问根结点。
  + 森林的遍历
    + 前序遍历：先访问森林中第一棵树的根结点，然后再依次先根遍历根的每棵子树，再依次用同样方式遍历除去第一棵树的剩余树构成的森林
    + 后序遍历：先访问森林中第一棵树，后根遍历的方式遍历每棵子树，然后再访问根结点，再依次同样方式遍历除去第一棵树的剩余树构成的森林

+ 赫夫曼树及其应用

  + 从树中一个结点到另一个结点之间的分支构成两个结点之间的路径，路径上的分支数目称作路径长度。
  + 树的路径长度就是从树根到每一结点的路径长度之和
  + 带权路径长度WPL最小的二叉树称作赫夫曼树
  + 赫夫曼算法
    1. 根据给定的n个权值{w<sub>1</sub>,w<sub>2</sub>,……，w<sub>n</sub>}构成n颗二叉树的集合F={T<sub>1</sub>,T<sub>2</sub>,……，T<sub>n</sub>}，其中每棵二叉树T<sub>i</sub>中只有一个带权为W<sub>i</sub>根结点，其左右子树均为空
    2. 在F中选取两颗根结点的权值最小的树作为左右子树构造一颗新的二叉树，且置新的二叉树的根结点的权值为其左右子树上根结点的权值之和
    3. 在F中删除这两颗树，同时将新得到的二叉树加入F中
    4. 重复2和3步骤，直到F只含一棵树为止。这棵树就是赫夫曼树
  + 赫夫曼编码：设需要编码的字符集为{d<sub>1</sub>,d<sub>2</sub>,……，d<sub>n</sub>}，各个字符在电文中出现的次数或频率结合为{w<sub>1</sub>,w<sub>2</sub>,……，w<sub>n</sub>}，以d<sub>1</sub>,d<sub>2</sub>,……，d<sub>n</sub>作为叶子结点，以w<sub>1</sub>,w<sub>2</sub>,……，w<sub>n</sub>作为相应叶子结点的权值来构造一颗赫夫曼树。规定赫夫曼树的左分支代表0，右分支代表1，则从根结点到叶子结点所经过的路径分支组成0和1的序列变为该结点对应的编码
    + 前缀编码：若要设计长短不等的编码，则必须是任一字符的编码都不是另一个字符的编码的前缀

#### 七.图

+ 图（graph）：是由顶点的有穷非空集合和顶点之间边的集合组成，通常表示为G（V，E），其中，G表示一个图，V是图G中顶点的集合，E是图G中边的集合
  + 线性表中我们把数据元素叫元素，树中将数据元素叫结点，在图中数据元素则称之为顶点（Vertex）
  + 线性表中可以没有数据元素，称为空表；树中可以没有结点，叫做空树；在图结构中，不允许没有顶点
  + 线性表中，相邻的数据元素之间具有线性关系；树结构中，相邻两层的结构具有层次关系；在图中，任意两个顶点之间都可能有关系，顶点之间的逻辑关系用边来表示，边集可以为空
  + 无向边：若顶点v<sub>i</sub>到v<sub>j</sub>之间的边没有方向，则称这条边为无向边，用无序偶对表示（v<sub>i</sub>，v<sub>j</sub>）
  + 无向图：图中任意两个顶点之间的边都是无向边
  + 有向边：若顶点v<sub>i</sub>到v<sub>j</sub>之间的边有方向，则称这条边为有向边，也称为弧。<v<sub>i</sub>，v<sub>j</sub>>
  + 有向图：图中任意两个顶点之间的边都是有向边
  + 简单图：若不存在顶点到其自身的边，且同一条边不重复出现，则称这样的图为简单图
  + 无向完全图：在无向图中，如果任意两个顶点之间都存在边，含有n个顶点有n*（n-1）/2条边
    + 对于无向图 G=（V，{E}），如果边（v，v'）∈ E，则称顶点v和v'互为邻接点，即v和v‘相邻接。边（v，v’）依附于顶点v和v‘，或者说（v，v’）与顶点v和v'相关联。顶点v的度是和v相关联的边的数目
  + 有向完全图：在有向图中，如果任意两个顶点之间都存在方向互为相反的两条弧边、，含有n个顶点有你n*（n-1）条边
    + 对于有向图 G=（V，{E}），如果弧<v，v'>∈ E，则称顶点v邻接到v'，顶点v‘邻接自顶点v。弧<v，v’>和顶点v和v‘相关联。以顶点v为头的弧的数目称为v的入度，记为ID（v）；以顶点v为尾的弧的数目称为v的出度，记为OD（v）；顶点v的度为TD（v） = ID（v）+ OD（v）
  + 稀疏图、稠密图
  + 权：与图的边或弧相关的数
  + 网：带权的图
  + 假设有两个图G=（V，{E}）和G'=（V'，{E'}）,如果V'⊆V且E'⊆E，则称G‘为G的子图
  + 路径的长度是路径上的边或弧的数目
+ 图的抽象数据类型
+ 图的存储结构
  + 邻接矩阵
  + 邻接表
  + 十字链表
  + 邻接多重表
  + 边集数组
+ 图的遍历：从图中某一顶点出发访遍图中其余顶点，且使每一个顶点仅被访问一次的过程
  + 深度优先遍历（DFS）
  + 广度优先遍历（BFS）
+ 最小生成树
  + 普里姆算法
  + 克鲁斯卡尔算法
+ 最短路径
  + 迪杰斯特拉算法
  + 弗洛伊德算法
+ 拓扑排序
+ 关键路径

#### 八.查找

#### 九.排序

#### 十. 总结

虽然我是一名前端工程师，但在实际开发过程中也会涉及到算法相关的问题，而算法和数据结构密切相关，数据结构又是计算机专业的基础课程，因此我需要补补课。

这本书通篇风趣幽默，没错，我目前看的书基本都是既基础又轻松的，这样可以加强我阅读的专注度和看完的决心。

看的过程中发现对很多概念和理念有了新的理解，当初读书时候很多专业名词只是死记硬背，在工作后有了一些项目经验，再回过头看对很多东西有一种豁然开朗的感觉。

算法和数据结构是相辅相成的，两者相互交叉，通过阅读《算法图解》、《大话数据结构》，能够对算法为什么那样写有更深的理解，对数据结构的把握和运用也能更深入。

我觉得，前端的深入学习和研究最终离不开后端相关的知识，只有深入了解计算机底层的设计和原理，多考虑实现过程中有哪些可行的方法和其优缺点，才能帮助我们更好地写代码，完成预期的需求。
