### 《大话数据结构》读书笔记

#### 一.数据结构绪论

+ 数据结构：相互之间存在一种或多种特定关系的数据元素的集合
+ 数据结构是一门研究非数值计算的程序设计问题中的操作对象，以及它们之间的关系和操作等相关问题的学科。
+ 程序设计 = 数据结构 + 算法
+ 数据：描述客观事物的符号，是计算机中可操作的对象，是能被计算机识别，并输入给计算机处理的符号集合
  + 数值类型：整型、实型等
  + 非数值型：字符、声音、图像、视频等
+ 数据元素：组成数据的、有一定意义的基本单位，在计算机中通常作为整体处理，也被称为记录
+ 数据项：一个数据元素可以由若干个数据项组成，是数据不可分割的最小单位
+ 数据对象：性质相同的数据元素的集合，是数据的子集
+ 逻辑结构：数据对象中数据元素之间的相互关系
  + 集合结构：集合结构中的数据元素除了同属于一个集合外，它们之间没有其他关系
  + 线性结构：线性结构中的数据元素之间是一对一的关系
  + 树形结构：树形结构中的数据元素之间存在一种一对多的层次关系
  + 图形结构：图形结构的数据元素是多对多的关系
+ 物理结构：是指数据的逻辑结构在计算机中的存储形式
  + 顺序存储结构：把数据元素存放在地址连续的存储单元里，其数据间的逻辑关系和物理关系是一致的
  + 链式存储结构：把数据元素存放在任意的存储单元里，这组存储单元可以是连续的，也可以是不连续的
+ 数据类型：一组性质相同的值的集合及定义在此集合上的一些操作的总称
+ 抽象：抽取出事物具有的普遍性的本质
+ 抽象数据类型：一个数学模型及定义在该模型上的一组操作
+ 抽象的意义在于数据类型的数学抽象特性
+ 抽象数据类型体现了程序设计中问题分解、抽象和信息隐藏的特性

#### 二.算法

+ 算法：解决特定问题求解步骤的描述，在计算机中表现为指令的有限序列，并且每条指令表示一个或多个操作

+ 算法的基本特性：
  + 输入：算法具有零个或多个输入
  + 输出：算法至少有一个或多个输出
  + 有穷性：算法在执行有限的步骤之后，自动结束而不会出现无限循环，并且每一个步骤在可接受的时间内完成
  + 确定性：算法的每一步骤都具有确定的含义，不会出现二义性
  + 可行性：算法的每一步必须是可行的，即每一步都能够通过执行有限次数完成
  
+ 算法设计的要求：
  + 正确性：算法至少应该具有输入、输出和加工处理无歧义性、能正确反映问题的需求、能够得到问题的正确答案
    + 算法正确性的四个层次
      1. 算法程序没有错误
      2. 算法程序对于合法的输入数据能够产生满足要求的输出结果
      3. 算法程序对于非法的输入数据能够得到满足规格说明的结果
      4. 算法程序对于精心选择的，甚至刁难的测试数据都有满足要求的输出结果
  + 可读性：便于阅读、理解和交流
  + 健壮性：当输入数据不合法时，算法也能够做出相关处理，而不是产生异常或莫名其妙的结果
  + 时间效率高和存储量低
  
+ 算法效率的度量方法
  + 事后统计法：主要是通过设计好的测试程序和数据，利用计算机计时器对不同算法编制的程序的运行时间进行比较，从而确定算法效率的高低（此方法缺陷较大）
  + 事前分析估算法：在计算机程序编制前，依据统计方法对算法进行估算
  
+ 函数的渐近增长：给定两个函数f(n)和g(n)，如果存在一个整数N，使得对于所有的n>N，f(n)总是比g(n)大，那么，我们说f(n)的增长渐近快于g(n)。
  + 可以忽略加法常数
  + 最高次项相乘的常数并不重要
  + 最高次项的指数大的，函数随着n的增长，结果也会变得增长特别快
  + 判断一个算法的效率时，函数中的常数和其他次要项常常可以忽略，而更应该关注主项（最高阶项）的阶数
  
+ 算法时间复杂度：在进行算法分析时，语句总的执行次数T(n)是关于问题规模n的函数，进而分析T(n)随n的变化情况并确定T(n)的数量级。记作：T(n) = O(f(n))。表示随问题规模n的增大，算法执行时间增长率和f(n)的增长率相同，称作算法的渐近时间复杂度，其中f(n)是问题规模n的某个函数

+ 推导大O阶方法：

  1. 用常数1取代运行时间中的多有加法常数
  2. 在修改后的运行次数函数中，只保留最高阶项
  3. 如果最高阶项存在且不是1，则去除与这个项相乘的常数。

+ 常见的时间复杂度：

  ![截屏2021-10-07 下午3.48.18](/Users/queen/Library/Application Support/typora-user-images/截屏2021-10-07 下午3.48.18.png)

  + O(1)<O(logn)<O(n)<O(nlogn)<O(n^2)<O(n^3)<O(2^n)<O(n!)<O(n^n)

+ 最坏情况：最坏情况运行时间是一种保证。通常，除非特别指定，我们提到的运行时间都是最坏情况的运行时间

+ 平均情况：平均运行时间是期望的运行时间

+ 算法空间复杂度：通过计算算法所需的存储空间实现，算法空间复杂度的计算公式记作：S(n) = O(f(n))，其中，n为问题的规模，f(n)为语句关于n所占存储空间的函数

+ 若算法执行时所需的辅助空间相对于输入数据量而言是个常数，则称此算法为原地工作，空间复杂度为O(1)

#### 三.线性表

+ 线性表(List)：零个或多个数据元素的有限序列

+ 数学语言定义：若将线性表记为（a<sub>1</sub>，……，a<sub>i-1</sub>，a<sub>i</sub>，a<sub>i+1</sub>,……，a<sub>n</sub>），则表中a<sub>i-1</sub>领先于a<sub>i</sub>，a<sub>i</sub>领先于a<sub>i+1</sub>,称a<sub>i-1</sub>是a<sub>i</sub>的直接先驱元素，a<sub>i+1</sub>是a<sub>i</sub>的直接后继元素。当i=1，2，……，n-1时，a<sub>i</sub>有且仅有一个直接后继，当当i=2，3，……，n时，a<sub>i</sub>有且仅有一个直接前驱。

+ 线性表元素的个数n（n≥0）定义为线性表的长度，当n=0，成为空表

+ 在复杂线性表中，一个数据元素可以由若干个数据项组成

+ 线性表的顺序存储结构：用一段地址连续的存储单元依次存储线性表的数据元素
  + 一维数组来实现顺序存储结构
  + 描述顺序存储结构的三个属性：
    1. 存储空间的其实位置：数值data，它的存储位置就是存储空间的存储位置
    2. 线性表的最大存储容量：数组长度MaxSize
    3. 线性表的当前长度：length
  
+ 在任意时刻，线性表的长度应该小于等于数组的长度

+ 地址：存储器中的每个存储单元都有自己的编号，这个编号称为地址
  + LOC(a<sub>i</sub>)=LOC(a<sub>1</sub>)+(i-1)*c
  
+ 顺序存储结构的插入与删除
  + 插入算法：
    + 如果插入位置不合理，抛出异常
    + 如果线性表长度大于等于数组长度，则抛出异常或动态增加容量
    + 从最后一个元素开始向前遍历到第i个位置，分别将它们都向后移动一个位置
    + 将要插入元素填入位置i处
    + 表长加1
  + 删除算法：
    + 如果删除位置不合理，抛出异常
    + 取出删除元素
    + 从删除元素位置开始遍历到最后一个元素位置，分别将它们都向前移动一个位置
    + 表长减1
  
+ 线性表顺序存储结构的优缺点
  + 优点：
    + 无须为表示表中元素之间的逻辑关系而增加额外的存储空间
    + 可以快速地存取表中任一位置的元素
  + 缺点：
    + 插入和删除操作需要移动大量元素
    + 当线性表长度变化较大时，难以确定存储空间的容量
    + 造成存储空间的“碎片”
  
+ 线性表链式存储结构定义：为了表示每个数据元素a<sub>i</sub>与其直接后继数据元素a<sub>i+1</sub>之间的逻辑关系，对数据元素a<sub>i</sub>来说，除了存储其本身的信息之外，还需要存储一个指示其直接后继的信息。我们把存储数据元素信息的域称为数据域，把存储直接后继位置的域称为指针域。指针域中存储的信息称做指针或链。这两部分信息组成数据元素a<sub>i</sub>的存储映像，称为结点Node。n个结点链结成一个链表，即为线性表的链式存储结构，因为此链表的每个结点中只包含一个指针域，所以叫做单链表

  + 头指针：链表中第一个节点的存储位置。线性链表的最后一个结点指针为“空”（NULL）

  + 头结点：单链表的第一个结点前附设的一个结点。头结点的数据域可以不存储任何信息

    ![截屏2021-10-11 下午9.03.17](/Users/queen/Library/Application Support/typora-user-images/截屏2021-10-11 下午9.03.17.png)

  + 如果p->data = a<sub>i</sub>,那么p->next->data = a<sub>i+1</sub>

+ 单链表的读取

  + 获得链表第i个数据的算法思路：
    1. 声明一个结点p指向链表第一个结点，初始化j从1开始	
    2. 当j<i时，就遍历链表，让p的指针向后移动，不断指向下一结点，j累加1
    3. 若到链表末尾p为空，则说明第i个元素不存在
    4. 否则查找成功，返回结点p的数据

+ 单链表的插入与删除：

  + 单链表第i个数据插入结点的算法：
    1. 声明一结点p指向链表第一个结点，初始化j从1开始
    2. 当j<i时，就遍历链表，让p的指针向后移动，不断指向下一结点，j累加1
    3. 若到链表末尾p为空，则说明第i个元素不存在
    4. 否则查找成功，在系统中生成一个空结点s
    5. 将数据元素e赋值给s->data
    6. 单链表的插入标准语句：s->next = p->next; p->next=s
    7. 返回成功

  + 单链表第i个数据删除结点的算法：
    1. 声明一结点p指向链表第一个结点，初始化j从1开始
    2. 当j<i时，就遍历链表，让p的指针向后移动，不断指向下一结点，j累加1
    3. 若到链表末尾p为空，则说明第i个元素不存在
    4. 否则查找成功，将欲删除的结点p->next赋值给q
    5. 单链表的删除标准语句p->next=q->next
    6. 将q结点中的数据赋值给e，作为返回
    7. 释放q结点
    8. 返回成功
  + 对于插入或删除数据越频繁的操作，单链表的效率优势就越明显

+ 单链表的整表创建：

  1. 声明一结点p和计数器表量i
  2. 初始化一空链表L
  3. 让L的头结点的指针指向NULL，即建立一个带头结点的单链表
  4. 循环
     + 生成一新结点赋值给p
     + 随机生成一数字赋值给p的数据域p->data
     + 将p插入到头结点与前一新结点之间

+ 单链表的整表删除：

  1. 声明一结点p和q
  2. 将第一个结点赋值给p
  3. 循环
     + 将下一结点赋值给q
     + 释放p
     + 将q赋值给p

+ 单链表结构与顺序存储结构优缺点

  ![截屏2021-10-11 下午9.54.02](/Users/queen/Library/Application Support/typora-user-images/截屏2021-10-11 下午9.54.02.png)

+ 静态链表：用数组描述的链表

+ 循环链表：将单链表中终端结点的指针端由空指针改为指向头结点，就使整个单链表形成一个环，这种头尾相接的单链表称为单循环链表

+ 双向链表：在单链表的每个结点中，再设置一个指向其前驱结点的指针域

#### 四.栈与队列

+ 栈：限定仅在表尾进行插入和删除操作的线性表，后进先出（LIFO）
  + 栈顶：允许插入和删除的一端
  + 栈底
  + 空栈：不含任何数据元素的栈
+ 进栈（push）出栈（pop）变化形式
  + 最先进栈的元素，不一定只能最后出栈
  + 312的出栈次序不会出现（只有三个元素的情况下）
+ 栈的顺序存储结构
  + 数组下标为0的一端作为栈底
  + 进栈和出栈的时间复杂度均为O（1）
  + 缺点：事先必须确定数组空间的大小，万一不够用了，就需要用编程手段扩展数组的容量
+ 两栈共享空间
  + 数组有两个端点，两个栈有两个栈底，让一个栈的栈底为数组的始端，即下标为0处，另一个栈为栈的末端，即下标为数组长度n-1处。如果两个栈增加元素，就是两端点栈向中间延伸（只针对两个具有相同数据类型的栈的技巧）
+ 栈的链式存储结构
  + 把栈顶放在单链表的头部
  + 进栈和出栈的时间复杂度都为O（1）
+ 如果栈的使用过程中元素变化不可预料，有时很小，有时非常大，那么最好是用连战，反之，如果它的变化在可控范围内，建议使用顺序栈
+ 栈的作用
  + 简化了程序设计的问题，划分了不同关注层次，使得思考范围缩小，更加聚焦于要解决的核心问题
+ 栈的应用
  + 递归：把一个直接调用自己或通过一系列的调用语句间接地调用自己的函数，称作递归函数。每一个递归定义必须至少满足一个条件，满足时递归不再进行，即不再引用自身而是返回值退出
    + 斐波那契数列：前面相邻两项之和，构成了后一项
    + 递归和迭代
      + 迭代：使用的是循环结构，不需要反复调用函数和占用额外的内存
      + 递归：使用的是选择结构，能使程序的结构更清晰、更简洁、更容易让人理解，从而减少读懂代码的时间，但大量的递归会建立函数的副本，耗费大量的时间和内存
  + 四则运算表达式求值
    + 后缀表示法：从左到右遍历表达式的每个数字和符号，遇到数字就进栈，遇到符号就将处于栈顶两个数字出栈，进行运算，运算结果进栈，一直到最终获得结果
    + 中缀表达式（标准四则运算表达式）转后缀表达式：从左到右遍历中缀表达式的每个数字和符号，若是数字就输出，即称为后缀表达式的一部分；若是符号，则判断其与栈顶符号优先级，是右括号或优先级低于栈顶符号则栈顶元素依次出栈并输出，并将当前符号进栈，一直到最终输出后缀表达式为止
+ 队列：只允许在一端进行插入操作、而在另一端进行删除操作的线性表，先进先出（FIFO）
+ 循环队列
  + 队列顺序存储不足：出队列的时间复杂度为O（n）
  + 定义：头尾相接的顺序存储结构
  + 队列计算长度公式：(rear-front+QueueSize)%QueueSize
  + 不足：面临数组可能会溢出的问题
+ 队列的链式存储结构
  + 线性表的单链表，只不过只能尾进头出
+ 循环队列和链队列的比较：
  + 时间上，它们的基本操作都是O（1），如果入队出队频繁，则还是有差异
  + 空间上，链队列更加灵活
  + 在可以确定队列长队最大值的情况下，建议用循环队列，如果无法预估队列长度，则用链队列

#### 五.串

#### 六.树

#### 七.图

#### 八.查找

#### 九.排序

#### 十. 总结

虽然我是一名前端工程师，但在实际开发过程中也会涉及到算法相关的问题，而算法和数据结构密切相关，数据结构又是计算机专业的基础课程，因此我需要补补课。

这本书通篇风趣幽默，没错，我目前看的书基本都是既基础又轻松的，这样可以加强我阅读的专注度和看完的决心。

看的过程中发现对很多概念和理念有了新的理解，当初读书时候很多专业名词只是死记硬背，在工作后有了一些项目经验，再回过头看对很多东西有一种豁然开朗的感觉

算法和数据结构是相辅相成的，两者相互交叉，通过阅读《算法》、《数据》，能够对算法为什么那样写有更深的理解，对数据结构的把握和运用也能更深入
